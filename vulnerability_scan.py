from image_scanner import *
import requests
import json
import os
import sys
from dotenv import load_dotenv 

load_dotenv()

NVD_API_KEY_ENV_VAR = "NVD_API_KEY"
api_key = os.environ.get(NVD_API_KEY_ENV_VAR)

if api_key is None:
    print(f"Error: The API key is not set.")
    print(f"Please set it as an environment variable '{NVD_API_KEY_ENV_VAR}' or in a .env file.")
    sys.exit(1)

url = "https://services.nvd.nist.gov/rest/json/cves/2.0"


def search_os(start_index=0, results_per_page=20,headers=None,params=None, data=None):
    if data is None:
        return
    #print(d['id'])
    #print(d['version_id'])
    params["keywordSearch"] = data['id'] + " " + data['version_id']
    response = requests.get(url, params=params, headers=headers)
    data = response.json()
    vulns = []
    if data["totalResults"] > 0:
            #print(f"Vulnerabilities found for {pkg_info['Package']}:")
        for vuln in data.get('vulnerabilities', []):
            #print(f"  - {vuln.get('cve', {}).get('id')}")
            vulns.append(vuln.get('cve', {}).get('id') + " " + vuln.get('cve', {}).get('descriptions', [{}])[0].get('value')[:100])
    #print(vulns)
    return vulns
    
    
def search_packages(start_index=0, results_per_page=50, headers=None,params=None, data=None):
    if data is None:
        return
    #print(d)
    packs = []
    for pkg in data:
        #params["keywordSearch"] =  pkg['name'] +" "+ pkg['version']
        packs.append(pkg['name'] )#+ " " + pkg['version'])
        #TODO: Fix this also (when using batch, version isn't required for some reason)
    #print(len(packs))
    #very hardcoded, will fix this later TODO:
    batched_vulnerabilities = []
    batched_packages = [[]]
    count = 0
    number_of_batches = 0
    for i in range(len(packs)):
        if i%50 == 0:
            batched_packages.append([])
            number_of_batches+=1
        batched_packages[number_of_batches].append(packs[i])
        count+=1
    #now batch request all these packages
    
    
    for i in range(len(batched_packages)):
#        params["keywordSearch"] = " OR ".join(p_t[i])
        params["keywordSearch"] = batched_packages[i]
#        print(params["keywordSearch"])
        
        
        response = requests.get(url, params=params, headers=headers)
        #print(response)
        if response.status_code != 200:
            continue
        data = response.json()
        #print(data)
        vulns = []
        vulns_by_package = {pkg: [] for pkg in batched_packages[i]}
        for vuln in data.get('vulnerabilities', []):
            for pkg in batched_packages[i]:
                if pkg in vuln.get('cve', {}).get('descriptions', [{}])[0].get('value', ''):
                    vulns_by_package[pkg].append(
                    vuln.get('cve', {}).get('id') + " " +
                    vuln.get('cve', {}).get('descriptions', [{}])[0].get('value')[:100]
                    )
        vulns.append(vulns_by_package)
    
        batched_vulnerabilities.append(vulns)
    return batched_vulnerabilities


def search_cve( start_index=0, results_per_page=20, txt_file=None,text_file2=None,flags=[]):
    if txt_file is None:
        return
    params = {
        "startIndex": start_index,
        "resultsPerPage": results_per_page,
        "cvssV2Severity": f[0] if len(flags)>0 else None,
    }
    headers = {}
    headers["apiKey"]=api_key
    image_data = json.load(open(txt_file))
    
    os_vulnerabilities = search_os(start_index,results_per_page,headers,params,data=image_data['os'])
    package_vulnerabilities = search_packages(start_index,results_per_page,headers,params,data=image_data['packages'])
    compiled_package_vulnerabilities = [] #probably would be good to in-space this instead of creating a new list
    for j in range(len(package_vulnerabilities)):
        for i in range(len(package_vulnerabilities[0])):
            print(package_vulnerabilities[j][i])
            compiled_package_vulnerabilities.append(package_vulnerabilities[j][i])
    if len(os_vulnerabilities)==0:
        os_vulnerabilities = []
    count = len(os_vulnerabilities)
    #print(len(p_v2))
    for i in range(len(compiled_package_vulnerabilities)):
        if len(compiled_package_vulnerabilities[i])==0:
            continue
        else:
            keys = compiled_package_vulnerabilities[i].keys()
            for key in keys:
                if len(compiled_package_vulnerabilities[i][key])==0:
                    continue
                else:
                    count+= len(compiled_package_vulnerabilities[i][key])
    result = {
        "os": os_vulnerabilities,
        "packages": compiled_package_vulnerabilities,
        "package_count": sum(len(x) for x in compiled_package_vulnerabilities),
        "Vulnerability_count": count
    }
    json.dump(result, open(text_file2, "w"), indent=4)

if __name__ == "__main__":
    flag = False
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <docker_image.tar>")
    if len(sys.argv) < 4:
        print(f"Optimal Usage: {sys.argv[0]} <docker_image.tar> <packages_output.json> <vulnerabilities_output.json>")
        print("OPTIONAL FLAGS: {cvssV2Severity: LOW,MEDIUM,HIGH} {serverity score: (0.0-10.0)} ")
        
    if len(sys.argv) > 4:
        flag = True
    if not (os.path.isfile(sys.argv[1])):
        print(f"Provided file: {sys.argv[0]} doesn't exist")
        sys.exit(1)
    
    #generates json to be analyzed
    result = analyze_docker_image_optimized(sys.argv[1],"packages_out.json") if len(sys.argv)<3 else analyze_docker_image_optimized(sys.argv[1], sys.argv[2])
    f = []
    if flag == True:
        for i in range(4,len(sys.argv)):
            f.append(sys.argv[i])
        #print(f)
    search_cve(0, 2000, txt_file=sys.argv[2], text_file2=sys.argv[3],flags = f) if len(sys.argv)>3 else search_cve(0, 2000, txt_file=sys.argv[2] if len(sys.argv)>2 else "packages_out.json", text_file2="vulnerable_out.json")
